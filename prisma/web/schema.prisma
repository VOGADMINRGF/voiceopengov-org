// prisma/web/schema.prisma — v3 (v1 + v2 merged)

generator client {
  provider = "prisma-client-js"
  // Beibehaltung aus v1
  output   = "../../apps/web/src/db/web"
}

datasource db {
  provider = "postgresql"
  // Beibehaltung aus v1; falls du WEB_DATABASE_URL nutzt, bitte ENV anpassen.
  url      = env("WEB_POSTGRES_URL")
}

//
// ---------- ENUMS ----------
enum ContentKind {
  // v1
  SWIPE
  EVENT
  SUNDAY_POLL
  // v2 ergänzt
  POST
  POLL
  QUIZ
  INFO
}

enum PublishStatus {
  draft
  review     // v1
  scheduled  // v2
  published
  archived
}

enum RegionMode {
  AUTO
  MANUAL
}

enum Locale {
  de
  en
  fr
  it
  es
  pl
  uk
  ru
  tr
  hi
  zh
  ar
}

//
// ---------- TAXONOMY (Topics/Tags) ----------
model Topic {
  id          String     @id @default(cuid())
  slug        String     @unique
  title       String
  description String?
  locale      Locale     @default(de)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  items ContentItem[]
  tags  TopicTag[]

  @@index([locale])
  @@index([createdAt])
}

model Tag {
  id     String  @id @default(cuid())
  slug   String  @unique
  label  String
  topics TopicTag[]
  items  ItemTag[]
}

model TopicTag {
  id      String @id @default(cuid())
  topicId String
  tagId   String

  topic Topic @relation(fields: [topicId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  tag   Tag   @relation(fields: [tagId],   references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@unique([topicId, tagId])
  @@index([topicId])
  @@index([tagId])
}

model ItemTag {
  id     String @id @default(cuid())
  itemId String
  tagId  String

  item ContentItem @relation(fields: [itemId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  tag  Tag         @relation(fields: [tagId],  references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@unique([itemId, tagId])
  @@index([itemId])
  @@index([tagId])
}

//
// ---------- REGION ----------
model Region {
  id    String @id @default(cuid())
  code  String @unique
  name  String
  level Int
}

//
// ---------- CONTENT ----------
model ContentItem {
  id        String      @id @default(cuid())
  kind      ContentKind

  // Topic
  topicId   String
  topic     Topic       @relation(fields: [topicId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  // Locale
  locale    Locale      @default(de)

  // Text
  title     String?
  text      String
  // v2: richText als strukturiertes JSON; (v1 hatte String?) – Migration s.u.
  richText  Json?

  // Sortierung
  sortOrder Int         @default(0) @map("order")

  // Publikations-Workflow
  status     PublishStatus @default(draft)
  authorName String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  publishAt  DateTime?
  expireAt   DateTime?

  // Region
  regionMode     RegionMode @default(AUTO)
  // v1: freie ID; v2: echte Relation – wir unterstützen beides
  regionManualId String?
  regionManual   Region?    @relation(fields: [regionManualId], references: [id], onDelete: SetNull)
  regionAuto     Json?
  // optional: effektive Region denormalisiert (v2-Idee)
  regionEffective Json?
  // (Optional beibehalten aus v1 – falls du eine berechnete ID persistierst)
  regionEffectiveId String?

  // Validierung/Metadaten
  validation Json?
  meta       Json?

  // Relationen
  answerOptions AnswerOption[]
  tags          ItemTag[]

  // Indizes
  @@index([kind, status, locale])
  @@index([locale, status, kind]) // v2-Kombiindex
  @@index([publishAt])
  @@index([topicId])
  @@index([createdAt])
}

model AnswerOption {
  id        String      @id @default(cuid())

  // v1-kompatible Relation/Feldnamen
  itemId    String
  item      ContentItem @relation(fields: [itemId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  label     String
  value     String
  sortOrder Int         @default(0) @map("order")
  exclusive Boolean     @default(false)
  meta      Json?

  @@unique([itemId, sortOrder])
  @@unique([itemId, value])
}
